<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Offline AES Locker</title>
  <style>
    :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    body { margin: 0; background: #0b1220; color: #e6edf3; }
    .wrap { max-width: 900px; margin: 0 auto; padding: 24px; }
    .card { background: #0f172a; border: 1px solid #1e293b; border-radius: 16px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,.25);}    
    h1 { font-size: 1.5rem; margin: 0 0 12px; }
    p.muted { color: #94a3b8; margin-top: 4px; }
    label { display:block; font-weight:600; margin: 16px 0 8px; }
    textarea, input[type="password"], input[type="text"] { width: 100%; background: #0b1220; color: #e6edf3; border: 1px solid #334155; border-radius: 12px; padding: 12px; box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    textarea { min-height: 120px; resize: vertical; }
    .row { display:flex; gap: 12px; align-items:center; }
    .row > * { flex: 1; }
    .btns { display:flex; gap: 12px; flex-wrap:wrap; margin-top: 16px; }
    button { appearance:none; cursor:pointer; border:1px solid #334155; background:#111827; color:#e6edf3; padding: 10px 14px; border-radius: 12px; font-weight:600; }
    button.primary{ background:#2563eb; border-color:#1d4ed8; }
    .out { background:#0b1220; border:1px dashed #334155; padding:12px; border-radius: 12px; min-height: 56px; white-space: pre-wrap; word-break: break-word; }
    .small { font-size: 12px; color: #94a3b8; }
    .ok { color:#22c55e; }
    .err{ color:#f87171; }
    .hint{font-size:12px;color:#a3a3a3;margin:6px 0 0}
    .footer{margin-top:18px;font-size:12px;color:#9ca3af}
    .kbd{font-family: ui-monospace, Menlo, Consolas, monospace; background:#111827; border:1px solid #334155; padding:0 6px; border-radius:6px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Offline AES Locker</h1>
      <p class="muted">Encrypt and decrypt short secrets locally in your browser. Nothing leaves this page.</p>

      <label for="secret">Secret (plain text)</label>
      <textarea id="secret" placeholder="Paste to ENCRYPT, leave empty when DECRYPTING."></textarea>

      <div class="row">
        <div>
          <label for="pass">Passphrase (memorizable secret)</label>
          <input id="pass" type="password" placeholder="Your little secret." autocomplete="off" />
          <div class="hint">This passphrase derives the key. You must remember it to decrypt later.</div>
        </div>
        <div>
          <label for="iterations">PBKDF2 iterations</label>
          <input id="iterations" type="text" placeholder="Shinra" autocomplete="off" />
          <div class="hint">Higher is slower but stronger. Keep the same value when decrypting.</div>
        </div>
      </div>

      <label for="cipher">Ciphertext (portable string)</label>
      <textarea id="cipher" placeholder="Will show salt:iv:ciphertext (Base64)."></textarea>

      <div class="btns">
        <button class="primary" id="btnEnc">Encrypt →</button>
        <button id="btnDec">← Decrypt</button>
        <button id="btnGen">Generate random secret</button>
        <button id="btnCopy">Copy ciphertext</button>
        <button id="btnWipe">Wipe fields</button>
      </div>

      <div id="status" class="small"></div>
      <div class="footer">Format: <span class="kbd">salt_b64:iv_b64:cipher_b64</span> using AES‑GCM(256) with key from PBKDF2‑HMAC‑SHA‑256. All local. Works offline.</div>
    </div>
  </div>

<script>
// Utility: Base64 <-> ArrayBuffer
function b64encode(buf){return btoa(String.fromCharCode(...new Uint8Array(buf)));}
function b64decode(str){return Uint8Array.from(atob(str), c=>c.charCodeAt(0)).buffer;}
function utf8enc(str){return new TextEncoder().encode(str);} 
function utf8dec(buf){return new TextDecoder().decode(buf);} 

async function deriveKey(pass, salt, iterations){
  const keyMaterial = await crypto.subtle.importKey(
    'raw', utf8enc(pass), {name:'PBKDF2'}, false, ['deriveKey']
  );
  return crypto.subtle.deriveKey(
    {name:'PBKDF2', salt, iterations, hash:'SHA-256'},
    keyMaterial,
    {name:'AES-GCM', length:256},
    false,
    ['encrypt','decrypt']
  );
}

function randBytes(n){return crypto.getRandomValues(new Uint8Array(n));}

async function encrypt(){
  const secret = document.getElementById('secret').value;
  const pass = document.getElementById('pass').value;
  const iters = parseInt(document.getElementById('iterations').value,10)||200000;
  const status = document.getElementById('status');
  if(!secret){ status.innerHTML = '<span class="err">Nothing to encrypt.</span>'; return; }
  if(!pass){ status.innerHTML = '<span class="err">Enter your passphrase.</span>'; return; }
  try{
    const salt = randBytes(16);
    const iv = randBytes(12);
    const key = await deriveKey(pass, salt, iters);
    const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, utf8enc(secret));
    const out = `${b64encode(salt)}:${b64encode(iv)}:${b64encode(ct)}`;
    document.getElementById('cipher').value = out;
    status.innerHTML = '<span class="ok">Encrypted. Save the ciphertext string.</span>';
  }catch(e){ status.innerHTML = `<span class="err">Encrypt error: ${e}</span>`; }
}

async function decrypt(){
  const pass = document.getElementById('pass').value;
  const iters = parseInt(document.getElementById('iterations').value,10)||200000;
  const status = document.getElementById('status');
  const c = document.getElementById('cipher').value.trim();
  if(!c){ status.innerHTML = '<span class="err">Paste a ciphertext string.</span>'; return; }
  if(!pass){ status.innerHTML = '<span class="err">Enter your passphrase.</span>'; return; }
  try{
    const [saltB64, ivB64, ctB64] = c.split(':');
    if(!saltB64 || !ivB64 || !ctB64) throw new Error('Malformed ciphertext (expected salt:iv:cipher).');
    const salt = new Uint8Array(b64decode(saltB64));
    const iv = new Uint8Array(b64decode(ivB64));
    const ct = b64decode(ctB64);
    const key = await deriveKey(pass, salt, iters);
    const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct);
    document.getElementById('secret').value = utf8dec(pt);
    status.innerHTML = '<span class="ok">Decrypted. Plain text is in the top box.</span>';
  }catch(e){ status.innerHTML = `<span class="err">Decrypt error: ${e.message||e}</span>`; }
}

function gen(){
  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_-+=[]{};:,.?/';
  const arr = new Uint32Array(35);
  crypto.getRandomValues(arr);
  let s='';
  for(let i=0;i<arr.length;i++){ s += alphabet[arr[i]%alphabet.length]; }
  document.getElementById('secret').value = s;
  document.getElementById('status').innerText = 'Generated 35‑char random secret.';
}

function copyCipher(){
  const c = document.getElementById('cipher');
  c.select(); c.setSelectionRange(0, 99999);
  document.execCommand('copy');
  document.getElementById('status').innerText = 'Ciphertext copied to clipboard.';
}

function wipe(){
  ['secret','pass','cipher'].forEach(id=>document.getElementById(id).value='');
  document.getElementById('status').innerText = 'Cleared.';
}

document.getElementById('btnEnc').addEventListener('click', encrypt);
-document.getElementById('btnDec').addEventListener('click', decrypt);
-document.getElementById('btnGen').addEventListener('click', gen);
-document.getElementById('btnCopy').addEventListener('click', copyCipher);
-document.getElementById('btnWipe').addEventListener('click', wipe);
</script>
</body>
</html>
